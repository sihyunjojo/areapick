# 상추:창고 Alert 서버

# FCM 준비사항
1. Firebase 프로젝트 생성:

- Firebase 콘솔(https://console.firebase.google.com/u/0/)에 접속합니다.
- "프로젝트 추가"를 클릭하여 새 프로젝트를 생성합니다.


2. 서비스 계정 키 파일:
- Firebase 콘솔에서 생성한 프로젝트로 이동합니다.
- 프로젝트 개요 옆의 "프로젝트 설정" > "서비스 계정" 탭으로 이동합니다.
- "새 비공개 키 생성" 버튼을 클릭하여 JSON 형식의 키 파일을 다운로드합니다.
- 이 파일을 프로젝트의 src/main/resources 디렉토리에 firebase-service-account.json이라는 이름으로 저장합니다.

# FCM 토큰
## 정책

### 토큰 수명
FCM 토큰은 일반적으로 영구적이지 않습니다.
토큰은 여러 가지 이유로 무효화되거나 변경될 수 있습니다.


#### 토큰 무효화 이유
- 앱 삭제 후 재설치
- 사용자가 기기의 백업을 복원
- 앱 데이터 삭제
- Firebase 인스턴스 ID의 보안 문제 감지


#### 토큰 갱신
- 토큰이 무효화되면 Firebase SDK는 자동으로 새 토큰을 생성합니다.
- 이는 앱이 실행 중일 때 발생할 수 있으며, 로그인 상태와는 무관합니다.


##### 로그인 중 토큰 갱신
- 이는 보안상의 이유로 또는 Firebase의 내부 정책에 따라 발생할 수 있습니다.


#### 토큰 모니터링
- 앱은 토큰 변경 이벤트를 모니터링해야 합니다.
- Firebase SDK는 토큰 새로 고침 이벤트를 제공합니다.


### 서버 측 처리
서버는 만료된 토큰으로 메시지 전송 시 오류 응답을 받게 됩니다.  
이 경우 해당 토큰을 무효화하고 사용자에게 새 토큰을 요청해야 합니다.  

# 알림 전체 흐름:

1. 사용자가 웹사이트 방문
2. 알림 권한 요청 및 FCM 토큰 생성
3. 토큰을 서버로 전송 및 저장
4. 서버에서 이벤트 발생 시 해당 사용자의 토큰으로 알림 전송
5. 브라우저가 열려 있으면 포그라운드 메시지로 처리
6. 브라우저가 백그라운드 상태면 서비스 워커가 알림 표시

## 토큰의 지속성 
- FCM 토큰은 일반적으로 브라우저 인스턴스마다 고유하며, 로그인/로그아웃에 관계없이 유지됩니다.
- 토큰은 브라우저 데이터가 지워지거나 특정 조건(예: 토큰 만료)에 따라 갱신될 때만 변경됩니다.

### 로그인 전 알림 처리:

브라우저별 고유 식별자(예: 브라우저 fingerprint)를 사용하여 로그인 전에도 알림을 연결할 수 있습니다.
로그인 시, 이 식별자와 연결된 알림을 사용자 계정과 연동합니다.


### 오프라인 알림 저장:

서버에서 알림을 발송할 때 사용자의 온라인/오프라인 상태를 확인합니다.
오프라인 상태의 사용자를 위해 알림을 데이터베이스에 저장합니다.


### 로그인 시 미발송 알림 처리:

사용자가 로그인할 때, 서버에서 해당 사용자의 미발송 알림을 확인합니다.
저장된 알림을 한 번에 또는 순차적으로 전송합니다.


# FCM 토큰을 어디서 처리할 건지에 대한 고민 

## 1. 카프카를 통해 FCM 토큰을 전송하는 방식:
장점:

알림 서버가 즉시 FCM 토큰을 사용할 수 있어 추가 데이터베이스 조회가 필요 없습니다.
네트워크 요청이 줄어들어 잠재적으로 더 빠른 처리가 가능합니다.

단점:

카프카 메시지 크기가 커질 수 있습니다.
FCM 토큰이 변경될 경우 동기화 문제가 발생할 수 있습니다.
보안 측면에서 민감한 FCM 토큰이 더 많이 노출될 수 있습니다.


## 2. 카프카로 userId만 전송하고 알림 서버에서 FCM 토큰을 조회하는 방식:
장점:

카프카 메시지가 더 간결해집니다.
FCM 토큰 관리가 중앙화되어 일관성 유지가 쉽습니다.
보안 측면에서 FCM 토큰의 노출을 줄일 수 있습니다.

단점:

알림 서버에서 추가적인 데이터베이스 조회가 필요합니다.
대량의 알림 처리 시 데이터베이스 부하가 증가할 수 있습니다.



## 결론
- **두 번째 방식**(**userId만 전송하고 알림 서버에서 FCM 토큰 조회**)이 더 적합할 것 같습니다. 이유는 다음과 같습니다:

- 데이터 일관성: FCM 토큰은 변경될 수 있으므로, 알림 서버에서 직접 조회하는 것이 최신 상태를 유지하기 쉽습니다.
- 유연성: getPendingNotificationsForUser 메서드와 같이 여러 알림을 한 번에 처리하는 경우, 데이터베이스에서 한 번의 조회로 FCM 토큰과 함께 필요한 정보를 모두 가져올 수 있습니다.
- 보안: FCM 토큰은 민감한 정보이므로, 카프카 메시지에 포함시키지 않는 것이 보안상 더 안전합니다.
- 확장성: 향후 FCM 토큰 외에 다른 정보가 필요해지더라도 알림 서버의 로직만 수정하면 되므로 확장이 용이합니다.

### 성능 최적화를 위한 제안

캐싱: 자주 접근하는 사용자의 FCM 토큰을 메모리 캐시(예: Redis)에 저장하여 데이터베이스 부하를 줄입니다.
배치 처리: 대량의 알림 처리 시 FCM 토큰 조회를 배치로 수행하여 데이터베이스 쿼리 수를 줄입니다.
비동기 처리: 알림 전송을 비동기로 처리하여 전체 시스템의 응답성을 향상시킵니다.

# 대기 중 이던 알림 보내는 법

1. 카프카 기반 알림 처리 (로그인 시 카프카 토픽 발행)
   - 장점:
     - 비동기적 이벤트 처리: 카프카는 이벤트 기반 시스템에서 비동기 처리에 강력합니다. 사용자가 로그인하면 로그인 서비스가 "user_logged_in"과 같은 이벤트를 발행하고, 알림 서버는 이 이벤트를 구독하여 대기 중인 알림을 처리합니다.
     - 서비스 간 느슨한 결합: 로그인 서비스와 알림 서비스가 직접적으로 통신하지 않기 때문에, 서비스 간 결합도가 낮아집니다. 알림 서버가 일시적으로 중단되더라도, 카프카는 메시지를 저장하고 서버가 복구되면 메시지를 처리할 수 있습니다.
     - 확장성: 카프카는 많은 양의 이벤트를 효율적으로 처리할 수 있어, 사용자 수가 증가하거나 대기 중인 알림이 많아져도 성능 저하가 적습니다.
   - 단점:
     - 복잡성: 이벤트 기반 아키텍처는 설정 및 운영이 다소 복잡할 수 있습니다. 카프카와 같은 메시징 시스템을 운영하고 모니터링해야 하며, 이로 인해 관리 비용이 증가할 수 있습니다.
     - 실시간성 보장 어려움: 카프카는 비동기적이기 때문에, 로그인 후 즉시 알림을 받아야 하는 요구사항이 있을 경우, 약간의 지연이 발생할 수 있습니다.
     - 오류 처리와 재시도 로직이 더 복잡해질 수 있습니다.

2. REST API 기반 알림 처리 (프론트에서 로그인 후 알림 서버로 요청)
   - 장점:
     - 단순성: REST API 요청은 구현과 운영이 상대적으로 간단합니다. 로그인 후 알림 서버에 바로 HTTP 요청을 보내 알림을 처리하는 방식이므로, 설정이 비교적 쉬운 편입니다.
     - 실시간 처리: 로그인 후 바로 알림 서버로 요청이 전달되므로, 실시간으로 알림을 보내는 데 적합합니다. 즉각적인 응답이 필요한 경우 유리합니다.
     - 클라이언트에서 요청 상태를 쉽게 추적할 수 있습니다.

   - 단점:
     - 직접 통신: 프론트엔드와 알림 서버가 직접적으로 통신하기 때문에, 서비스 간 결합도가 상대적으로 높습니다. 알림 서버가 일시적으로 중단되면 요청이 실패할 수 있습니다.
     - 확장성 한계: 사용자가 많아질수록 REST API 요청이 증가하여 알림 서버의 부하가 커질 수 있습니다. 이벤트 기반 시스템만큼의 확장성은 제공하지 못할 수 있습니다.
     - 확장성이 제한적일 수 있습니다.
     
## 결론
- 알림을 즉시 처리하지 않아도 되고, 여러 서비스가 독립적으로 동작하는 것이 필요하다면 이 방식이 유리합니다.
- 반면, 즉각적인 알림 처리가 중요한 소규모 시스템이거나, 서비스 복잡도를 낮추고 싶다면 REST API 요청 방식이 더 적합할 수 있습니다.

## 추천
확장성과 비동기 이벤트 처리가 중요한 대규모 시스템에서는 **카프카를 통한 이벤트 발행**이 더 적합할 수 있습니다.   

- 느슨한 결합: 서비스 간 직접적인 의존성을 줄일 수 있습니다.
- 확장성: 추후 다른 마이크로서비스들도 로그인 이벤트를 활용할 수 있습니다.
- 장애 격리: 알림 서버의 일시적인 문제가 로그인 프로세스에 영향을 주지 않습니다.
- 비동기 처리: 대량의 알림 처리를 비동기적으로 수행할 수 있어 시스템 부하를 분산시킬 수 있습니다. 

요약하자면, 확장성과 비동기 처리가 중요한 경우 카프카를, 즉각적인 처리와 단순성을 원하는 경우 REST API 방식을 고려해보는 것이 좋습니다.

# DB 동기화 방식

